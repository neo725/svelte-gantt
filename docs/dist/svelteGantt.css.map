{
  "version": 3,
  "file": "svelteGantt.css",
  "sources": [
    "../../Gantt.svelte",
    "../../Column.svelte",
    "../../ColumnHeaderRow.svelte",
    "../../Columns.svelte",
    "../../Milestone.svelte",
    "../../Row.svelte",
    "../../Task.svelte",
    "../../TimeRange.svelte",
    "../../TimeRangeHeader.svelte",
    "../../Arrow.svelte",
    "../../Dependency.svelte",
    "../../GanttDependencies.svelte",
    "../../Table.svelte",
    "../../TableRow.svelte",
    "../../TableTreeCell.svelte"
  ],
  "sourcesContent": [
    "<script>\n  import { onMount, setContext, tick, onDestroy } from 'svelte'\n  import { writable, derived } from 'svelte/store'\n  import moment from 'moment'\n\n  let ganttElement\n  let mainHeaderContainer\n  let mainContainer\n  let rowContainer\n  let scrollables = []\n  let mounted = false\n\n  import {\n    rowStore,\n    taskStore,\n    timeRangeStore,\n    allTasks,\n    allRows,\n    allTimeRanges,\n    rowTaskCache,\n  } from './core/store'\n  import { Task, Row, TimeRange, TimeRangeHeader, Milestone } from './entities'\n  import { Columns, ColumnHeader } from './column'\n  // import { Resizer } from './ui'\n\n  import { GanttUtils, getPositionByDate } from './utils/utils'\n  import { getRelativePos, debounce, throttle } from './utils/domUtils'\n  import { SelectionManager } from './utils/selectionManager'\n  import { GanttApi } from './core/api'\n  import { TaskFactory, reflectTask } from './core/task'\n  import { RowFactory } from './core/row'\n  import { TimeRangeFactory } from './core/timeRange'\n  import { DragDropManager } from './core/drag'\n  import { findByPosition, findByDate } from './core/column'\n  import { onEvent, onDelegatedEvent, offDelegatedEvent } from './core/events'\n\n  export let rows\n  export let tasks = []\n  export let timeRanges = []\n  $: if (mounted) initRows(rows)\n  $: if (mounted) initTasks(tasks)\n  $: if (mounted) initTimeRanges(timeRanges)\n\n  export let rowPadding = 6\n  export let rowHeight = 48\n  const _rowHeight = writable(rowHeight)\n  const _rowPadding = writable(rowPadding)\n\n  export let from\n  export let to\n  const _from = writable(from)\n  const _to = writable(to)\n  $: $_from = from\n  $: $_to = to\n\n  export let minWidth = 800\n  export let fitWidth = false\n  const _minWidth = writable(minWidth)\n  const _fitWidth = writable(fitWidth)\n  $: {\n    $_minWidth = minWidth\n    $_fitWidth = fitWidth\n  }\n\n  export let classes = []\n  export let headers = [\n    { unit: 'day', format: 'MMMM Do' },\n    { unit: 'hour', format: 'H:mm' },\n  ]\n  export let zoomLevels = [\n    {\n      headers: [\n        { unit: 'day', format: 'DD.MM.YYYY' },\n        { unit: 'hour', format: 'HH' },\n      ],\n      minWidth: 800,\n      fitWidth: true,\n    },\n    {\n      headers: [\n        { unit: 'hour', format: 'ddd D/M, H A' },\n        { unit: 'minute', format: 'mm', offset: 15 },\n      ],\n      minWidth: 5000,\n      fitWidth: false,\n    },\n  ]\n  export let taskContent = null\n  export let tableWidth = 100\n  export let resizeHandleWidth = 10\n  export let onTaskButtonClick = null\n\n  export let magnetUnit = 'minute'\n  export let magnetOffset = 15\n  export let columnUnit = 'minute'\n  export let columnOffset = 15\n\n  // export until Svelte3 implements Svelte2's setup(component) hook\n  export let ganttTableModules = []\n  export let ganttBodyModules = []\n\n  export let reflectOnParentRows = true\n  export let reflectOnChildRows = false\n\n  export let columnStrokeColor\n  export let columnStrokeWidth\n\n  const visibleWidth = writable()\n  const visibleHeight = writable()\n  const headerHeight = writable()\n  const _width = derived(\n    [visibleWidth, _minWidth, _fitWidth],\n    ([visible, min, stretch]) => {\n      return stretch && visible > min ? visible : min\n    },\n  )\n\n  export const columnService = {\n    getColumnByDate(date) {\n      const pair = findByDate(columns, date)\n      return !pair[0] ? pair[1] : pair[0]\n    },\n    getColumnByPosition(x) {\n      const pair = findByPosition(columns, x)\n      return !pair[0] ? pair[1] : pair[0]\n    },\n    getPositionByDate(date) {\n      if (!date) return null\n      const column = this.getColumnByDate(date)\n\n      let durationTo = date.diff(column.from, 'milliseconds')\n      const position = (durationTo / column.duration) * column.width\n\n      //multiples - skip every nth col, use other duration\n      return column.left + position\n    },\n    getDateByPosition(x) {\n      const column = this.getColumnByPosition(x)\n      x = x - column.left\n\n      let positionDuration = (column.duration / column.width) * x\n      const date = moment(column.from).add(positionDuration, 'milliseconds')\n\n      return date\n    },\n    /**\n     *\n     * @param {Moment} date - Date\n     * @returns {Moment} rounded date passed as parameter\n     */\n    roundTo(date) {\n      let value = date.get(magnetUnit)\n      value = Math.round(value / magnetOffset)\n      date.set(magnetUnit, value * magnetOffset)\n\n      //round all smaller units to 0\n      const units = [\n        'millisecond',\n        'second',\n        'minute',\n        'hour',\n        'date',\n        'month',\n        'year',\n      ]\n      const indexOf = units.indexOf(magnetUnit)\n      for (let i = 0; i < indexOf; i++) {\n        date.set(units[i], 0)\n      }\n      return date\n    },\n  }\n\n  const columnWidth = writable(\n    getPositionByDate(\n      $_from.clone().add(columnOffset, columnUnit),\n      $_from,\n      $_to,\n      $_width,\n    ) | 0,\n  )\n  $: $columnWidth =\n    getPositionByDate(\n      $_from.clone().add(columnOffset, columnUnit),\n      $_from,\n      $_to,\n      $_width,\n    ) | 0\n  let columnCount = Math.ceil($_width / $columnWidth)\n  $: columnCount = Math.ceil($_width / $columnWidth)\n  let columns = getColumns(\n    $_from,\n    columnCount,\n    columnOffset,\n    columnUnit,\n    $columnWidth,\n  )\n  $: columns = getColumns(\n    $_from,\n    columnCount,\n    columnOffset,\n    columnUnit,\n    $columnWidth,\n  )\n\n  function getColumns(from, count, offset, unit, width) {\n    let columns = []\n    let columnFrom = from.clone()\n    let left = 0\n    for (let i = 0; i < count; i++) {\n      const from = columnFrom.clone()\n      const to = columnFrom.add(offset, unit)\n      const duration = to.diff(from, 'milliseconds')\n\n      columns.push({\n        width: width,\n        from,\n        left,\n        duration,\n      })\n      left += width\n      columnFrom = to\n    }\n\n    return columns\n  }\n\n  const dimensionsChanged = derived([columnWidth, _from, _to], () => ({}))\n  $: {\n    if ($dimensionsChanged) {\n      refreshTasks()\n      refreshTimeRanges()\n    }\n  }\n\n  setContext('dimensions', {\n    from: _from,\n    to: _to,\n    width: _width,\n    visibleWidth,\n    visibleHeight,\n    headerHeight,\n    dimensionsChanged,\n  })\n\n  setContext('options', {\n    taskContent,\n    rowPadding: _rowPadding,\n    rowHeight: _rowHeight,\n    resizeHandleWidth: resizeHandleWidth,\n    reflectOnParentRows,\n    reflectOnChildRows,\n    onTaskButtonClick,\n  })\n\n  const hoveredRow = writable()\n  const selectedRow = writable()\n\n  const ganttContext = {\n    scrollables,\n    hoveredRow,\n    selectedRow,\n  }\n  setContext('gantt', ganttContext)\n\n  onMount(() => {\n    Object.assign(ganttContext, {\n      rowContainer,\n      mainContainer,\n      mainHeaderContainer,\n    })\n\n    api.registerEvent('tasks', 'move')\n    api.registerEvent('tasks', 'select')\n    api.registerEvent('tasks', 'switchRow')\n    api.registerEvent('tasks', 'moveEnd')\n    api.registerEvent('tasks', 'change')\n    api.registerEvent('tasks', 'changed')\n    api.registerEvent('gantt', 'viewChanged')\n\n    mounted = true\n  })\n\n  onDelegatedEvent('click', 'data-task-id', (event, data, target) => {\n    const taskId = +data\n    if (event.ctrlKey) {\n      selectionManager.toggleSelection(taskId)\n    } else {\n      selectionManager.selectSingle(taskId)\n    }\n    api.tasks.raise.select($taskStore.entities[taskId])\n  })\n\n  onDelegatedEvent('mouseover', 'data-row-id', (event, data, target) => {\n    $hoveredRow = +data\n  })\n\n  onDelegatedEvent('click', 'data-row-id', (event, data, target) => {\n    $selectedRow = +data\n  })\n\n  onDestroy(() => {\n    offDelegatedEvent('click', 'data-task-id')\n    offDelegatedEvent('click', 'data-row-id')\n  })\n\n  let __scrollTop = 0\n  let __scrollLeft = 0\n  function scrollable(node) {\n    const onscroll = (event) => {\n      const { scrollTop, scrollLeft } = node\n\n      scrollables.forEach((scrollable) => {\n        if (scrollable.orientation === 'horizontal') {\n          scrollable.node.scrollLeft = scrollLeft\n        } else {\n          scrollable.node.scrollTop = scrollTop\n        }\n      })\n\n      __scrollTop = scrollTop\n      __scrollLeft = scrollLeft\n    }\n\n    node.addEventListener('scroll', onscroll)\n    return {\n      destroy() {\n        node.removeEventListener('scroll', onscroll, false)\n      },\n    }\n  }\n\n  function horizontalScrollListener(node) {\n    scrollables.push({ node, orientation: 'horizontal' })\n  }\n\n  function onResize(event) {\n    tableWidth = event.detail.left\n  }\n\n  let zoomLevel = 0\n  let zooming = false\n  async function onwheel(event) {\n    if (event.ctrlKey) {\n      event.preventDefault()\n\n      const prevZoomLevel = zoomLevel\n      if (event.deltaY > 0) {\n        zoomLevel = Math.max(zoomLevel - 1, 0)\n      } else {\n        zoomLevel = Math.min(zoomLevel + 1, zoomLevels.length - 1)\n      }\n\n      if (prevZoomLevel != zoomLevel && zoomLevels[zoomLevel]) {\n        const options = {\n          columnUnit: columnUnit,\n          columnOffset: columnOffset,\n          minWidth: $_minWidth,\n          ...zoomLevels[zoomLevel],\n        }\n\n        const scale = options.minWidth / $_width\n        const node = mainContainer\n        const mousepos = getRelativePos(node, event)\n        const before = node.scrollLeft + mousepos.x\n        const after = before * scale\n        const scrollLeft = after - mousepos.x + node.clientWidth / 2\n\n        console.log('scrollLeft', scrollLeft)\n\n        columnUnit = options.columnUnit\n        columnOffset = options.columnOffset\n        $_minWidth = options.minWidth\n\n        if (options.headers) headers = options.headers\n\n        if (options.fitWidth) $_fitWidth = options.fitWidth\n\n        api.gantt.raise.viewChanged()\n        zooming = true\n        await tick()\n        node.scrollLeft = scrollLeft\n        zooming = false\n      }\n    }\n  }\n\n  function onDateSelected(event) {\n    $_from = event.detail.from.clone()\n    $_to = event.detail.to.clone()\n  }\n\n  function initRows(rowsData) {\n    const rows = rowFactory.createRows(rowsData)\n    rowStore.addAll(rows)\n  }\n\n  async function initTasks(taskData) {\n    await tick()\n\n    const tasks = []\n    const opts = { rowPadding: $_rowPadding }\n    taskData.forEach((t) => {\n      const task = taskFactory.createTask(t)\n      const row = $rowStore.entities[task.model.resourceId]\n      task.reflections = []\n\n      if (reflectOnChildRows && row.allChildren) {\n        row.allChildren.forEach((r) => {\n          const reflectedTask = reflectTask(task, r, opts)\n          task.reflections.push(reflectedTask.model.id)\n          tasks.push(reflectedTask)\n        })\n      }\n\n      if (reflectOnParentRows && row.allParents.length > 0) {\n        row.allParents.forEach((r) => {\n          const reflectedTask = reflectTask(task, r, opts)\n          task.reflections.push(reflectedTask.model.id)\n          tasks.push(reflectedTask)\n        })\n      }\n\n      tasks.push(task)\n    })\n    taskStore.addAll(tasks)\n  }\n\n  function initTimeRanges(timeRangeData) {\n    const timeRanges = timeRangeData.map((timeRange) => {\n      return timeRangeFactory.create(timeRange)\n    })\n    timeRangeStore.addAll(timeRanges)\n  }\n\n  function onModuleInit(module) {}\n\n  async function tickWithoutCSSTransition() {\n    disableTransition = false\n    await tick()\n    ganttElement.offsetHeight // force a reflow\n    disableTransition = true\n  }\n\n  export const api = new GanttApi()\n  const selectionManager = new SelectionManager()\n\n  export const taskFactory = new TaskFactory(columnService)\n  $: {\n    taskFactory.rowPadding = $_rowPadding\n    taskFactory.rowEntities = $rowStore.entities\n  }\n\n  export const rowFactory = new RowFactory()\n  $: rowFactory.rowHeight = rowHeight\n\n  export const dndManager = new DragDropManager(rowStore)\n  export const timeRangeFactory = new TimeRangeFactory(columnService)\n\n  export const utils = new GanttUtils()\n  $: {\n    utils.from = $_from\n    utils.to = $_to\n    utils.width = $_width\n    utils.magnetOffset = magnetOffset\n    utils.magnetUnit = magnetUnit\n  }\n\n  setContext('services', {\n    utils,\n    api,\n    dndManager,\n    selectionManager,\n    columnService,\n  })\n\n  export function refreshTimeRanges() {\n    timeRangeStore._update(({ ids, entities }) => {\n      ids.forEach((id) => {\n        const timeRange = entities[id]\n        const newLeft =\n          columnService.getPositionByDate(timeRange.model.from) | 0\n        const newRight = columnService.getPositionByDate(timeRange.model.to) | 0\n\n        timeRange.left = newLeft\n        timeRange.width = newRight - newLeft\n      })\n      return { ids, entities }\n    })\n  }\n\n  export function refreshTasks() {\n    $allTasks.forEach((task) => {\n      const newLeft = columnService.getPositionByDate(task.model.from) | 0\n      const newRight = columnService.getPositionByDate(task.model.to) | 0\n\n      task.left = newLeft\n      task.width = newRight - newLeft\n    })\n\n    taskStore.refresh()\n  }\n\n  export function getRowContainer() {\n    return rowContainer\n  }\n\n  export function selectTask(id) {\n    const task = $taskStore.entities[id]\n    if (task) {\n      selectionManager.selectSingle(task)\n    }\n  }\n\n  export function unselectTasks() {\n    selectionManager.clearSelection()\n  }\n\n  export function scrollToRow(id, scrollBehavior = 'auto') {\n    const { scrollTop, clientHeight } = mainContainer\n\n    const index = $allRows.findIndex((r) => r.model.id == id)\n    if (index === -1) return\n    const targetTop = index * rowHeight\n\n    if (targetTop < scrollTop) {\n      mainContainer.scrollTo({\n        top: targetTop,\n        behavior: scrollBehavior,\n      })\n    }\n\n    if (targetTop > scrollTop + clientHeight) {\n      mainContainer.scrollTo({\n        top: targetTop + rowHeight - clientHeight,\n        behavior: scrollBehavior,\n      })\n    }\n  }\n\n  export function scrollToTask(id, scrollBehavior = 'auto') {\n    const { scrollLeft, scrollTop, clientWidth, clientHeight } = mainContainer\n\n    const task = $taskStore.entities[id]\n    if (!task) return\n    const targetLeft = task.left\n    const rowIndex = $allRows.findIndex(\n      (r) => r.model.id == task.model.resourceId,\n    )\n    const targetTop = rowIndex * rowHeight\n\n    const options = {\n      top: undefined,\n      left: undefined,\n      behavior: scrollBehavior,\n    }\n\n    if (targetLeft < scrollLeft) {\n      options.left = targetLeft\n    }\n\n    if (targetLeft > scrollLeft + clientWidth) {\n      options.left = targetLeft + task.width - clientWidth\n    }\n\n    if (targetTop < scrollTop) {\n      options.top = targetTop\n    }\n\n    if (targetTop > scrollTop + clientHeight) {\n      options.top = targetTop + rowHeight - clientHeight\n    }\n\n    mainContainer.scrollTo(options)\n  }\n\n  export function updateTask(model) {\n    const task = taskFactory.createTask(model)\n    taskStore.upsert(task)\n  }\n\n  export function updateTasks(taskModels) {\n    const tasks = taskModels.map((model) => taskFactory.createTask(model))\n    taskStore.upsertAll(tasks)\n  }\n\n  export function updateRow(model) {\n    const row = rowFactory.createRow(model)\n    rowStore.upsert(row)\n  }\n\n  export function updateRows(rowModels) {\n    const rows = rowModels.map((model) => rowFactory.createRow(model))\n    rowStore.upsertAll(rows)\n  }\n\n  export function getRow(resourceId) {\n    return $rowStore.entities[resourceId]\n  }\n\n  export function getTask(id) {\n    return $taskStore.entities[id]\n  }\n\n  export function getTasks(resourceId) {\n    if ($rowTaskCache[resourceId]) {\n      return $rowTaskCache[resourceId].map((id) => $taskStore.entities[id])\n    }\n    return null\n  }\n\n  let filteredRows = []\n  $: filteredRows = $allRows.filter((row) => !row.hidden)\n\n  let rightScrollbarVisible\n  $: rightScrollbarVisible = rowContainerHeight > $visibleHeight\n\n  let rowContainerHeight\n  $: rowContainerHeight = filteredRows.length * rowHeight\n\n  let startIndex\n  $: startIndex = Math.floor(__scrollTop / rowHeight)\n\n  let endIndex\n  $: endIndex = Math.min(\n    startIndex + Math.ceil($visibleHeight / rowHeight),\n    filteredRows.length - 1,\n  )\n\n  let paddingTop = 0\n  $: paddingTop = startIndex * rowHeight\n\n  let paddingBottom = 0\n  $: paddingBottom = (filteredRows.length - endIndex - 1) * rowHeight\n\n  let visibleRows = []\n  $: visibleRows = filteredRows.slice(startIndex, endIndex + 1)\n\n  let visibleTasks\n  $: {\n    const tasks = []\n    visibleRows.forEach((row) => {\n      if ($rowTaskCache[row.model.id]) {\n        $rowTaskCache[row.model.id].forEach((id) => {\n          tasks.push($taskStore.entities[id])\n        })\n      }\n    })\n    visibleTasks = tasks\n  }\n\n  let noVisibleRows = false\n  $: noVisibleRows = visibleRows.length == 0\n\n  let disableTransition = true\n  $: if ($dimensionsChanged) tickWithoutCSSTransition()\n</script>\n\n<style>\n  .sg-disable-transition :global(.sg-task),\n  .sg-disable-transition :global(.sg-milestone) {\n    transition: transform 0s, background-color 0.2s, width 0s !important;\n  }\n\n  :global(.sg-view:not(:first-child)) {\n    margin-left: 5px;\n  }\n\n  /* This class should take into account varying widths of the scroll bar */\n  .right-scrollbar-visible {\n    padding-right: 17px;\n  }\n\n  .sg-timeline {\n    flex: 1 1 0%;\n    display: flex;\n    flex-direction: column;\n    overflow-x: auto;\n  }\n\n  .sg-gantt {\n    display: flex;\n\n    width: 100%;\n    height: 100%;\n    position: relative;\n  }\n\n  .sg-foreground {\n    box-sizing: border-box;\n    overflow: hidden;\n    top: 0;\n    left: 0;\n    position: absolute;\n    width: 100%;\n    height: 100%;\n    z-index: 1;\n    pointer-events: none;\n  }\n\n  .sg-rows {\n    width: 100%;\n    box-sizing: border-box;\n    overflow: hidden;\n  }\n\n  .sg-timeline-body {\n    overflow: auto;\n    flex: 1 1 auto;\n  }\n\n  .sg-header {\n  }\n\n  .header-container {\n  }\n\n  .sg-header-scroller {\n    border-right: 1px solid #efefef;\n    overflow: hidden;\n    position: relative;\n  }\n\n  .content {\n    position: relative;\n  }\n\n  :global(*) {\n    box-sizing: border-box;\n  }\n</style>\n\n<div\n  class=\"sg-gantt {classes}\"\n  class:sg-disable-transition={!disableTransition}\n  bind:this={ganttElement}\n  on:click={onEvent}\n  on:mouseover={onEvent}>\n  {#each ganttTableModules as module}\n    <svelte:component\n      this={module}\n      {rowContainerHeight}\n      {paddingTop}\n      {paddingBottom}\n      {tableWidth}\n      {...$$restProps}\n      on:init={onModuleInit}\n      {visibleRows} />\n\n    <!-- <Resizer x={tableWidth} on:resize={onResize} container={ganttElement} /> -->\n  {/each}\n\n  <div\n    class=\"sg-timeline sg-view rows-count-{visibleRows.length}\"\n    class:sg-timeline-rows-0={noVisibleRows}>\n    <div\n      class=\"sg-header\"\n      bind:this={mainHeaderContainer}\n      bind:clientHeight={$headerHeight}\n      class:right-scrollbar-visible={rightScrollbarVisible}>\n      <div class=\"sg-header-scroller\" use:horizontalScrollListener>\n        <div class=\"header-container\" style=\"width:{$_width}px\">\n          <ColumnHeader\n            {headers}\n            {columnUnit}\n            {columnOffset}\n            on:dateSelected={onDateSelected} />\n          {#each $allTimeRanges as timeRange (timeRange.id)}\n            <TimeRangeHeader {...timeRange} />\n          {/each}\n        </div>\n      </div>\n    </div>\n\n    <div\n      class=\"sg-timeline-body\"\n      bind:this={mainContainer}\n      use:scrollable\n      class:zooming\n      on:wheel={onwheel}\n      bind:clientHeight={$visibleHeight}\n      bind:clientWidth={$visibleWidth}>\n      <div class=\"content\" style=\"width:{$_width}px\">\n        <Columns {columns} {columnStrokeColor} {columnStrokeWidth} />\n        <div\n          class=\"sg-rows\"\n          bind:this={rowContainer}\n          style=\"height:{rowContainerHeight}px;\">\n          <div style=\"transform: translateY({paddingTop}px);\">\n            {#each visibleRows as row (row.model.id)}\n              <Row {row} />\n            {/each}\n          </div>\n        </div>\n        <div class=\"sg-foreground\">\n          {#each $allTimeRanges as timeRange (timeRange.id)}\n            <TimeRange {...timeRange} />\n          {/each}\n\n          {#each visibleTasks as task (task.model.id)}\n            <Task\n              model={task.model}\n              left={task.left}\n              width={task.width}\n              height={task.height}\n              top={task.top}\n              {...task} />\n          {/each}\n        </div>\n        {#each ganttBodyModules as module}\n          <svelte:component\n            this={module}\n            {paddingTop}\n            {paddingBottom}\n            {visibleRows}\n            {...$$restProps}\n            on:init={onModuleInit} />\n        {/each}\n      </div>\n    </div>\n  </div>\n  <div class=\"sg-table sg-view\">\n    <div class=\"sg-table-header\">\n      <div class=\"sg-table-header-cell sg-table-cell sg-table-header-cell-last\">\n        <div>\n          <i class=\"fas fa-angle-right\" />\n        </div>\n        <div>\n          <i class=\"fas fa-angle-double-right\" />\n        </div>\n      </div>\n    </div>\n  </div>\n</div>\n",
    "<script>\n    export let left;\n    export let width;\n</script>\n\n<div class=\"column\" style=\"left:{left}px;width:{width}px\"></div>\n<style>\n    .column {\n        position: absolute;\n        height: 100%;\n        box-sizing: border-box;\n    }\n    \n    .column {\n        border-right: #efefef 1px solid;\n    }\n</style>",
    "<script>\n  import { createEventDispatcher, getContext } from 'svelte'\n\n  const dispatch = createEventDispatcher()\n\n  import { duration as momentDuration } from 'moment'\n\n  const { from, to, width } = getContext('dimensions')\n\n  export let header\n  export let baseWidth\n  export let baseDuration\n\n  export let columnWidth\n  $: {\n    const offset = header.offset || 1\n    const duration = momentDuration(offset, header.unit).asMilliseconds()\n    const ratio = duration / baseDuration\n    columnWidth = baseWidth * ratio\n  }\n\n  export let columnCount\n  $: {\n    columnCount = Math.ceil($width / columnWidth)\n    if (!isFinite(columnCount)) {\n      console.error('columnCount is not finite')\n      columnCount = 0\n    }\n  }\n\n  let _headers = []\n  $: {\n    const headers = []\n    let headerTime = $from.clone().startOf(header.unit)\n    const offset = header.offset || 1\n\n    for (let i = 0; i < columnCount; i++) {\n      let _header = {\n        width: Math.min(columnWidth, $width),\n        label: headerTime.format(header.format),\n        from: headerTime.clone(),\n        to: headerTime.clone().add(offset, header.unit),\n        unit: header.unit,\n        classes: header.classes,\n      }\n\n      let isMarkToday = header['today'] || false\n\n      if (isMarkToday && _header.from.isSame(new Date(), 'day')) {\n        _header.label = 'TODAY'\n\n        let _classes = _header['classes'] || ''\n        if (_classes.length > 0) {\n          _classes += ' '\n        }\n        _classes += 'sg-table-header-cell-today'\n        _header.classes = _classes\n      }\n\n      headers.push(_header)\n\n      headerTime.add(offset, header.unit)\n    }\n    _headers = headers\n  }\n</script>\n\n<style>\n  .column-header-row {\n    box-sizing: border-box;\n    white-space: nowrap;\n    height: 32px;\n  }\n\n  .column-header-cell {\n    display: inline-block;\n    height: 100%;\n    box-sizing: border-box;\n    text-overflow: clip;\n    /* vertical-align: top; */\n    text-align: center;\n\n    display: inline-flex;\n    justify-content: center;\n    align-items: center;\n    font-size: 1em;\n    font-size: 14px;\n    font-weight: 300;\n    transition: background 0.2s;\n\n    /* cursor: pointer; */\n    user-select: none;\n\n    border-right: #efefef 1px solid;\n    border-bottom: #efefef 1px solid;\n  }\n\n  /* .column-header-cell:hover {\n    background: #f9f9f9;\n  } */\n\n  .column-header-cell.sticky > .column-header-cell-label {\n    position: sticky;\n    left: 1rem;\n  }\n</style>\n\n<div class=\"column-header-row\">\n  {#each _headers as _header}\n    <div\n      class=\"column-header-cell {_header.classes || ''}\"\n      class:sticky={_header.sticky}\n      style=\"width:{_header.width}px\">\n      <div class=\"column-header-cell-label\">{_header.label || 'N/A'}</div>\n    </div>\n  {/each}\n</div>\n",
    "<script>\n    import { getContext, onMount } from 'svelte';\n    \n    import Column from './Column.svelte';\n    /**\n     * Container component for columns rendered as gantt body background\n     */\n    export let columns = [];\n\n    export let columnStrokeWidth = 1;\n    export let columnStrokeColor = '#efefef';\n\n    function lineAt(ctx, x) {\n        ctx.beginPath();\n        ctx.moveTo(x, 0);\n        ctx.lineTo(x, 20);\n        ctx.stroke();\n    }\n\n    function createBackground(columns) {\n        const canvas = document.createElement('canvas');\n        canvas.width = (columns.length - 1) * columns[0].width;\n        canvas.height = 20;\n\n        const ctx = canvas.getContext('2d');\n        ctx.shadowColor = \"rgba(128,128,128,0.5)\";\n        ctx.shadowOffsetX = 0;\n        ctx.shadowOffsetY = 0;\n        ctx.shadowBlur = 0.5;\n        ctx.lineWidth = columnStrokeWidth;\n        ctx.lineCap = \"square\";\n        ctx.strokeStyle = columnStrokeColor;\n        ctx.translate(0.5, 0.5);\n\n        columns.forEach(column => {\n            lineAt(ctx, column.left);\n        });\n\n        const dataURL = canvas.toDataURL();\n        return `url(\"${dataURL}\")`;\n    }\n\n    let backgroundImage;\n    $: {\n        backgroundImage = createBackground(columns.slice(0,5));\n    }\n</script>\n\n<div class=\"sg-columns\" style=\"background-image:{backgroundImage};\">\n\t<!-- {#each columns as column}\n\t<Column left={column.left} width={column.width} />\n\t{/each} -->\n</div>\n<style>\n    .sg-columns {\n        position: absolute;\n        height: 100%;\n        width: 100%;\n        overflow: hidden;\n\n        background-repeat: repeat;\n        background-position-x: -1px;\n    }\n</style>",
    "<script>\n    import { beforeUpdate, onMount, getContext } from 'svelte';\n\n    let milestoneElement;\n\n    import { Draggable } from '../core/drag';\n    import { rowStore, taskStore } from '../core/store';\n    const { rowPadding } = getContext('options');\n    const { selectionManager, api, rowContainer, dndManager, columnService} = getContext('services');\n\n    export let left;\n    export let top;\n    export let model;\n    export let height = 20;\n\n    const selection = selectionManager.selection;\n\n    let dragging = false;\n    let x = null;\n    let y = null;\n    $: {\n        if(!dragging){\n            x = left, y = top;\n        }\n    }\n\n    function drag(node) {\n        const ondrop = ({ x, y, currWidth, event, dragging }) => {\n            let rowChangeValid = true;\n            //row switching\n            if(dragging){\n                const sourceRow = $rowStore.entities[model.resourceId];\n                const targetRow = dndManager.getTarget('row', event);\n                if(targetRow){\n                    model.resourceId = targetRow.model.id;\n                    api.tasks.raise.switchRow(this, targetRow, sourceRow);\n                }\n                else{\n                    rowChangeValid = false;\n                }\n            }\n            \n            dragging = false;\n            const task = $taskStore.entities[model.id];\n            if(rowChangeValid) {\n                const newFrom = utils.roundTo(columnService.getDateByPosition(x)); \n                const newLeft = columnService.getPositionByDate(newFrom);\n\n                Object.assign(model, {\n                    from: newFrom\n                });\n                \n                $taskStore.update({\n                    ...task,\n                    left: newLeft,\n                    top: rowPadding + $rowStore.entities[model.resourceId].y,\n                    model\n                });\n            }\n            else {\n                // reset position\n                $taskStore.update({\n                    ...task\n                });\n            }\n        }\n\n        const draggable = new Draggable(node, {\n            onDown: ({x, y}) => {\n                //this.set({x, y});\n            }, \n            onDrag: (pos) => {\n                x = pos.x, y = pos.y, dragging = true;\n            },\n            dragAllowed: () => {\n                return row.model.enableDragging && model.enableDragging;\n            },\n            resizeAllowed: false,\n            onDrop: ondrop, \n            container: rowContainer, \n            getX: () => x,\n            getY: () => y\n        });\n\n        return {\n            destroy() { draggable.destroy(); }\n        }\n    }\n\n    onMount(() => {\n        x = left = columnService.getPositionByDate(model.from); \n        y = top = row.y + $rowPadding;; \n        height = row.height - 2 * $rowPadding;\n    });\n\n    export function select(event) {\n        if(event.ctrlKey){\n            selectionManager.toggleSelection(model.id);\n        }\n        else{\n            selectionManager.selectSingle(model.id);\n        }\n        \n        if(selected){\n            api.tasks.raise.select(model);\n        }\n    }\n\n    let selected = false;\n    $: selected = $selection.indexOf(model.id) !== -1;\n\n    let row;\n    $: row = $rowStore.entities[model.resourceId];\n</script>\n\n<div bind:this={milestoneElement}\n    class=\"sg-milestone {model.classes}\" \n    style=\"transform: translate({x}px, {y}px);height:{height}px;width:{height}px\"\n    use:drag \n    on:click=\"{select}\"\n    class:selected=\"{selected}\"\n    class:moving=\"{dragging}\">\n    <div class=\"inside\"></div>\n        <!-- <span class=\"debug\">x:{x|0} y:{y|0}, x:{left|0} y:{top|0}</span> -->\n</div>\n\n<style>\n    .sg-milestone {\n\t\tposition: absolute;     \n        top: 0;\n        bottom: 0;\n\n        white-space: nowrap;\n        /* overflow: hidden; */\n\n        height: 20px;\n        width: 20px;\n\n        min-width: 40px;\n        margin-left: -20px;\n        display: flex;\n        align-items: center;\n        flex-direction: column;\n\n        transition: background-color 0.2s, opacity 0.2s;\n    }\n\n    .sg-milestone .inside {\n        position: relative;\n    }\n\n    .sg-milestone .inside:before {\n        position: absolute;\n        top: 0;\n        left: 0;\n        content: ' ';\n        height: 28px;\n        width: 28px;\n        transform-origin: 0 0;\n        transform: rotate(45deg); \n        /* //after -45 */\n        background-color: #feac31;\n        border-color: #feac31;\n    }\n\n    .sg-milestone:not(.moving) {\n        transition: transform 0.2s, background-color 0.2s, width 0.2s;\n    }\n\n    .sg-milestone.moving{\n        z-index: 1;\n    }\n\n    .sg-milestone.selected {\n        outline: 2px solid rgba(3, 169, 244, 0.5);\n        outline-offset: 3px;\n        z-index: 1;\n    }\n</style>",
    "<script>\n    import { getContext } from 'svelte';\n    export let row;\n    let rowElement;\n\n    const { rowHeight } = getContext('options');\n    const { hoveredRow, selectedRow } = getContext('gantt');\n</script>\n\n<div class=\"sg-row {row.model.classes}\" data-row-id=\"{row.model.id}\" class:sg-hover={$hoveredRow == row.model.id} class:sg-selected={$selectedRow == row.model.id} bind:this={rowElement} style=\"height:{$rowHeight}px\">\n    {#if row.model.contentHtml}\n        {@html row.model.contentHtml}\n    {/if}\n</div>    \n<style>\n    .sg-row {\n        position: relative;\n        width: 100%;\n        box-sizing: border-box;\n    }\n</style>",
    "<script>\n  import {\n    beforeUpdate,\n    afterUpdate,\n    getContext,\n    onMount,\n    onDestroy,\n    tick,\n  } from 'svelte'\n\n  import { setCursor } from 'src/utils/domUtils'\n  import { taskStore, rowStore } from '../core/store'\n  import { Draggable } from '../core/drag'\n  import { reflectTask } from 'src/core/task'\n\n  export let model\n  export let height\n  export let left\n  export let top\n  export let width\n  export let reflected = false\n\n  let animating = true\n\n  let _dragging = false\n  let _resizing = false\n\n  let _position = {\n    x: left,\n    y: top,\n    width: width,\n  }\n\n  $: updatePosition(left, top, width)\n  function updatePosition(x, y, width) {\n    if (!_dragging && !_resizing) {\n      _position.x = x\n      _position.y = y //row.y + 6;\n      _position.width = width\n      // should NOT animate on resize/update of columns\n    }\n  }\n\n  const { dimensionsChanged } = getContext('dimensions')\n  const { rowContainer } = getContext('gantt')\n  const {\n    taskContent,\n    resizeHandleWidth,\n    rowPadding,\n    onTaskButtonClick,\n    reflectOnParentRows,\n    reflectOnChildRows,\n  } = getContext('options')\n  const {\n    dndManager,\n    api,\n    utils,\n    selectionManager,\n    columnService,\n  } = getContext('services')\n\n  function drag(node) {\n    const ondrop = (event) => {\n      let rowChangeValid = true\n      //row switching\n      const sourceRow = $rowStore.entities[model.resourceId]\n      if (event.dragging) {\n        const targetRow = dndManager.getTarget('row', event.mouseEvent)\n        if (targetRow) {\n          model.resourceId = targetRow.model.id\n          api.tasks.raise.switchRow(this, targetRow, sourceRow)\n        } else {\n          rowChangeValid = false\n        }\n      }\n\n      _dragging = _resizing = false\n\n      const task = $taskStore.entities[model.id]\n\n      if (rowChangeValid) {\n        const prevFrom = model.from\n        const prevTo = model.to\n        const newFrom = (model.from = utils.roundTo(\n          columnService.getDateByPosition(event.x),\n        ))\n        const newTo = (model.to = utils.roundTo(\n          columnService.getDateByPosition(event.x + event.width),\n        ))\n        const newLeft = columnService.getPositionByDate(newFrom) | 0\n        const newRight = columnService.getPositionByDate(newTo) | 0\n\n        const targetRow = $rowStore.entities[model.resourceId]\n        const left = newLeft\n        const width = newRight - newLeft\n        const top = $rowPadding + targetRow.y\n\n        updatePosition(left, top, width)\n\n        const newTask = {\n          ...task,\n          left: left,\n          width: width,\n          top: top,\n          model,\n        }\n\n        const changed =\n          !prevFrom.isSame(newFrom) ||\n          !prevTo.isSame(newTo) ||\n          (sourceRow && sourceRow.model.id !== targetRow.model.id)\n        if (changed) {\n          api.tasks.raise.change({ task: newTask, sourceRow, targetRow })\n        }\n\n        taskStore.update(newTask)\n\n        if (changed) {\n          api.tasks.raise.changed({ task: newTask, sourceRow, targetRow })\n        }\n\n        // update shadow tasks\n        if (newTask.reflections) {\n          taskStore.deleteAll(newTask.reflections)\n        }\n\n        const reflectedTasks = []\n        if (reflectOnChildRows && targetRow.allChildren) {\n          if (!newTask.reflections) newTask.reflections = []\n\n          const opts = { rowPadding: $rowPadding }\n          targetRow.allChildren.forEach((r) => {\n            const reflectedTask = reflectTask(newTask, r, opts)\n            newTask.reflections.push(reflectedTask.model.id)\n            reflectedTasks.push(reflectedTask)\n          })\n        }\n\n        if (reflectOnParentRows && targetRow.allParents.length > 0) {\n          if (!newTask.reflections) newTask.reflections = []\n\n          const opts = { rowPadding: $rowPadding }\n          targetRow.allParents.forEach((r) => {\n            const reflectedTask = reflectTask(newTask, r, opts)\n            newTask.reflections.push(reflectedTask.model.id)\n            reflectedTasks.push(reflectedTask)\n          })\n        }\n\n        if (reflectedTasks.length > 0) {\n          taskStore.upsertAll(reflectedTasks)\n        }\n\n        if (!(targetRow.allParents.length > 0) && !targetRow.allChildren) {\n          newTask.reflections = null\n        }\n      } else {\n        // reset position\n        ;(_position.x = task.left),\n          (_position.width = task.width),\n          (_position.y = task.top)\n      }\n    }\n\n    const draggable = new Draggable(node, {\n      onDown: (event) => {\n        if (event.dragging) {\n          setCursor('move')\n        }\n        if (event.resizing) {\n          setCursor('e-resize')\n        }\n      },\n      onMouseUp: () => {\n        setCursor('default')\n      },\n      onResize: (event) => {\n        ;(_position.x = event.x),\n          (_position.width = event.width),\n          (_resizing = true)\n      },\n      onDrag: (event) => {\n        ;(_position.x = event.x), (_position.y = event.y), (_dragging = true)\n      },\n      dragAllowed: () => {\n        return row.model.enableDragging && model.enableDragging\n      },\n      resizeAllowed: () => {\n        return row.model.enableDragging && model.enableDragging\n      },\n      onDrop: ondrop,\n      container: rowContainer,\n      resizeHandleWidth,\n      getX: () => _position.x,\n      getY: () => _position.y,\n      getWidth: () => _position.width,\n    })\n    return {\n      destroy: () => draggable.destroy(),\n    }\n  }\n\n  export function onclick(event) {\n    if (onTaskButtonClick) {\n      onTaskButtonClick(task)\n    }\n  }\n\n  let selection = selectionManager.selection\n  let selected = false\n  $: selected = $selection.indexOf(model.id) !== -1\n\n  let row\n  $: row = $rowStore.entities[model.resourceId]\n</script>\n\n<style>\n  .sg-label-bottom {\n    position: absolute;\n    top: calc(100% + 10px);\n    color: #888;\n  }\n\n  .debug {\n    position: absolute;\n    top: -10px;\n    right: 0;\n    font-size: 8px;\n    color: black;\n  }\n\n  .sg-task {\n    position: absolute;\n\n    white-space: nowrap;\n    /* overflow: hidden; */\n\n    transition: background-color 0.2s, opacity 0.2s;\n    pointer-events: all;\n  }\n\n  .sg-task-background {\n    position: absolute;\n    height: 100%;\n    top: 0;\n  }\n\n  .sg-task-content {\n    position: absolute;\n    height: 100%;\n    top: 0;\n\n    padding-left: 14px;\n    font-size: 14px;\n    display: flex;\n    align-items: center;\n    justify-content: flex-start;\n  }\n\n  .sg-task:not(.moving) {\n    transition: transform 0.2s, background-color 0.2s, width 0.2s;\n  }\n\n  .sg-task.moving {\n    z-index: 1;\n    opacity: 0.5;\n  }\n\n  .sg-task:hover::before {\n    content: '';\n    width: 4px;\n    height: 50%;\n    top: 25%;\n    position: absolute;\n    cursor: ew-resize;\n    border-style: solid;\n    border-color: rgba(255, 255, 255, 0.5);\n\n    margin-left: 3px;\n    left: 0;\n    border-width: 0 1px;\n    z-index: 1;\n  }\n\n  .sg-task:hover::after {\n    content: '';\n    width: 4px;\n    height: 50%;\n    top: 25%;\n    position: absolute;\n    cursor: ew-resize;\n    border-style: solid;\n    border-color: rgba(255, 255, 255, 0.5);\n\n    margin-right: 3px;\n    right: 0;\n    border-width: 0 1px;\n    z-index: 1;\n  }\n\n  .sg-task.selected {\n    outline: 2px solid rgba(3, 169, 244, 0.5);\n    outline-offset: 3px;\n    z-index: 1;\n  }\n\n  .sg-task-reflected {\n    opacity: 0.5;\n  }\n\n  .sg-task-background {\n    background: rgba(0, 0, 0, 0.2);\n  }\n\n  :global(.sg-task) {\n    color: white;\n    background: rgb(116, 191, 255);\n  }\n\n  :global(.sg-task:hover) {\n    background: rgb(98, 161, 216);\n  }\n\n  :global(.sg-task.selected) {\n    background: rgb(69, 112, 150);\n  }\n</style>\n\n<div\n  data-task-id={model.id}\n  use:drag\n  class=\"sg-task {model.classes}\"\n  style=\"width:{_position.width}px; max-height:{height}px; transform: translate({_position.x}px,\n  {_position.y}px);\"\n  class:moving={_dragging || _resizing}\n  class:selected\n  class:animating\n  class:sg-task-reflected={reflected}>\n  {#if model.amountDone}\n    <div class=\"sg-task-background\" style=\"width:{model.amountDone}%\" />\n  {/if}\n  <div class=\"sg-task-content\">\n    {#if model.html}\n      {@html model.html}\n    {:else if taskContent}\n      {@html taskContent(model)}\n    {:else}{model.label}{/if}\n    <!-- <span class=\"debug\">x:{_position.x} y:{_position.y}, x:{left} y:{top}</span> -->\n    {#if model.showButton}\n      <span class=\"sg-task-button {model.buttonClasses}\" on:click={onclick}>\n        {@html model.buttonHtml}\n      </span>\n    {/if}\n  </div>\n\n  {#if model.labelBottom}\n    <label class=\"sg-label-bottom\">{model.labelBottom}</label>\n  {/if}\n</div>\n",
    "<script>\n    export let model;\n    export let left;\n    export let width;\n    export let resizing = false;\n\n    const _position = {\n        width,\n        x: left\n    }\n    $: {\n        _position.x = left, _position.width = width;\n    };\n</script>\n\n<div class=\"sg-time-range\" class:moving=\"{resizing}\" style=\"width:{_position.width}px;left:{_position.x}px\">\n    <div class=\"sg-time-range-label\">{model.label}</div>\n</div>\n<style>\n    .sg-time-range {\n        height: 100%;\n        position: absolute;\n        display: flex;\n        flex-direction: column;\n        align-items: center;\n\n        background-image: linear-gradient(-45deg, rgba(0, 0, 0, 0) 46%, #e03218 49%, #e03218 51%, rgba(0, 0, 0, 0) 55%);\n        background-size: 6px 6px !important;\n        color: red;\n        font-weight: 400;\n    }\n\n    .sg-time-range-label {\n        margin-top: 10px;\n        background: #fff;\n        white-space: nowrap;\n        padding: 4px;\n        font-weight: 400;\n        font-size: 10px;\n    }\n</style>",
    "<script>\n    import { beforeUpdate, getContext } from 'svelte';\n\n    import { Draggable } from '../core/drag';\n    import { timeRangeStore } from '../core/store';\n\n    const { rowContainer } = getContext('gantt');\n    const { utils, columnService } = getContext('services');\n    const { resizeHandleWidth } = getContext('options');\n    const {\n        from,\n        to,\n        width: ganttWidth,\n        visibleWidth\n    } = getContext('dimensions');\n\n    export let model;\n    export let width;\n    export let left;\n    \n    const _position = {\n        width,\n        x: left\n    }\n    $: {\n        _position.x = left, _position.width = width;\n    };\n\n    function drag(node) {\n        const ondrop = (event) => {\n            const newFrom = utils.roundTo(columnService.getDateByPosition(event.x)); \n            const newTo = utils.roundTo(columnService.getDateByPosition(event.x + event.width));\n            const newLeft = columnService.getPositionByDate(newFrom);\n            const newRight = columnService.getPositionByDate(newTo);\n            \n            Object.assign(model, {\n                from: newFrom,\n                to: newTo\n            });\n\n            update({\n                left: newLeft,\n                width: newRight - newLeft,\n                model,\n                resizing: false\n            });\n\n            window.removeEventListener('mousemove', onmousemove, false);\n        };\n\n        function update(state) {\n            timeRangeStore.update(state);\n            _position.x = state.left;\n            _position.width = state.width;\n        }\n\n        return new Draggable(node, {\n            onDown: (event) => {\n                update({\n                    left: event.x,\n                    width: event.width,\n                    model,\n                    resizing: true\n                });\n            }, \n            onResize: (event) => {\n                update({\n                    left: event.x,\n                    width: event.width,\n                    model,\n                    resizing: true\n                });\n            },\n            dragAllowed: false,\n            resizeAllowed: true,\n            onDrop: ondrop, \n            container: rowContainer, \n            resizeHandleWidth,\n            getX: () => _position.x,\n            getY: () => 0,\n            getWidth: () => _position.width\n        });\n    }\n</script>\n\n<div class=\"sg-time-range-control\" style=\"width:{_position.width}px;left:{_position.x}px\">\n    <div class=\"sg-time-range-handle-left\" use:drag></div>\n    <div class=\"sg-time-range-handle-right\" use:drag></div>\n</div>\n<style>\n    .sg-time-range-control {\n        position: absolute;\n    }\n\n    .sg-time-range-handle-left {\n        position: absolute;\n        left: 0;\n    }\n\n    .sg-time-range-handle-right {\n        position: absolute;\n        right: 0;\n    }\n\n    .sg-time-range-handle-left::before, .sg-time-range-handle-right::before {\n        position: absolute;\n        content: '';\n        bottom: 4px;\n        border-radius: 6px 6px 6px 0;\n        border: 2px solid #b0b0b7;\n        width: 9px;\n        height: 9px;\n        transform: translateX(-50%) rotate(-45deg);\n        background-color: #fff;\n\n        border-color: #e03218;\n        cursor: ew-resize;\n    }\n</style>",
    "<script>\n    import { onMount } from 'svelte';\n\n    export let startY;\n    export let endY;\n    export let endX;\n    export let startX;\n    export let minLen = 12;\n    export let arrowSize = 5;\n    export let stroke = 'red';\n    export let strokeWidth = 2;\n\n    onMount(() => {\n\n    });\n\n    let height;\n    $: height = endY - startY;\n\n    let width;\n    $: width = endX - startX;\n\n    let path;\n    $: {\n        if (startX == NaN || startX == undefined)\n            path = 'M0 0';\n\n        let result;\n        if (startX + minLen >= endX && startY != endY) {\n            result = `L ${startX + minLen} ${startY} \n                        L ${startX + minLen} ${startY + height / 2}\n                        L ${endX - minLen} ${startY + height / 2}\n                        L ${endX - minLen} ${endY} `\n        }\n        else {\n            result = `L ${startX + width / 2} ${startY} \n                        L ${startX + width / 2} ${endY}`\n        }\n\n        // -2 so the line doesn't stick out of the arrowhead\n        path = `M${startX} ${startY}` + result + `L ${endX - 2} ${endY}`\n    }\n\n    let arrowPath;\n    $: {\n        if (endX == NaN || endX == undefined)\n            arrowPath = 'M0 0';\n\n        arrowPath = `M${endX - arrowSize} ${endY - arrowSize} L${endX} ${endY} L${endX - arrowSize} ${endY + arrowSize} Z`\n    }\n</script>\n\n<svg xmlns=\"http://www.w3.org/2000/svg\" shape-rendering=\"crispEdges\" class=\"arrow\" height=\"100%\" width=\"100%\">\n    <path d=\"{path}\" {stroke} stroke-width=\"{strokeWidth}\" fill=\"transparent\" class=\"select-area\" />\n    <path d=\"{arrowPath}\" fill=\"{stroke}\" />\n</svg>\n\n<style>\n    .arrow {\n        position: absolute;\n        left: 0px;\n        pointer-events: none;\n    }\n\n    .select-area {\n        pointer-events: visible;\n        position: absolute;\n    }\n</style>",
    "<script>\n    import Arrow from './Arrow.svelte';\n\n    import { taskStore } from '../../core/store';\n\n    export let id;\n    export let fromId;\n    export let toId;\n\n    let fromTask;\n    $: fromTask = $taskStore.entities[fromId];\n\n    let toTask;\n    $: toTask = $taskStore.entities[toId];\n</script>\n\n<div class=\"sg-dependency\" style=\"left:0;top:0\" data-dependency-id=\"{id}\">\n    <Arrow startX={fromTask.left + fromTask.width} startY={fromTask.top + fromTask.height / 2} endX={toTask.left}\n        endY={toTask.top + toTask.height / 2} />\n</div>\n\n<style>\n    .sg-dependency {\n        position: absolute;\n        width: 100%;\n        height: 100%;\n    }\n</style>",
    "<script context=\"module\">\n    const type = 'body';\n</script>\n\n<script>\n    import { getContext } from 'svelte';\n\n    import Dependency from './Dependency.svelte';\n    \n    import { taskStore } from '../../core/store';\n\n    const { visibleHeight } = getContext('dimensions');\n\n    export let paddingTop;\n    export let dependencies = [];\n\n    let visibleDependencies = [];\n    $: {\n        const result = [];\n        for (let i = 0; i < dependencies.length; i++) {\n            const dependency = dependencies[i];\n            const map = $taskStore.entities;\n\n            const fromTask = map[dependency.fromId];\n            const toTask = map[dependency.toId];\n            if(\n                fromTask && toTask \n                && Math.min(fromTask.top, toTask.top) <= paddingTop + $visibleHeight \n                && Math.max(fromTask.top, toTask.top) >= paddingTop\n            ) {\n                result.push(dependency);\n            }\n        }\n        visibleDependencies = result;\n    }\n</script>\n\n<div class=\"dependency-container\">\n    {#each visibleDependencies as dependency (dependency.id)}\n        <Dependency {...dependency}/>\n    {/each}\n</div>\n\n<style>\n    .dependency-container {\n        position: absolute;\n        width: 100%;\n        height: 100%;\n        \n        pointer-events: none;\n        top: 0;\n        float: left;\n        overflow: hidden;\n        z-index: 0;\n    }\n</style>",
    "<script context=\"module\">\n  export const type = 'table'\n</script>\n\n<script>\n  import { createEventDispatcher, onMount, getContext } from 'svelte'\n\n  const dispatch = createEventDispatcher()\n\n  import TableRow from './TableRow.svelte'\n  import { H_SCROLLBAR_WIDTH } from 'src/core/constants'\n  import { rowStore, taskStore } from '../../core/store'\n\n  export let tableWidth\n  export let paddingTop\n  export let paddingBottom\n  export let rowContainerHeight\n  export let visibleRows\n  // list of columns used in the table\n  // title: label to display in the header\n  // property: property of row to display in the cell\n  // width: width of column\n  export let tableHeaders = [\n    {\n      title: 'Name',\n      property: 'label',\n      width: 100,\n      classes: '',\n      headerHtml: '',\n    },\n  ]\n  export let tableLastHeaders = [\n    {\n      title: 'Name',\n      property: 'label',\n      width: 100,\n      classes: '',\n      headerHtml: '',\n    },\n  ]\n\n  const { from, to, width, visibleWidth, headerHeight } = getContext(\n    'dimensions',\n  )\n  const { rowPadding, rowHeight } = getContext('options')\n\n  onMount(() => {\n    dispatch('init', { module: this })\n  })\n\n  const { scrollables } = getContext('gantt')\n  let headerContainer\n  function scrollListener(node) {\n    scrollables.push({ node, orientation: 'vertical' })\n\n    node.addEventListener('scroll', (event) => {\n      headerContainer.scrollLeft = node.scrollLeft\n    })\n\n    return {\n      destroy() {\n        node.removeEventListener('scroll')\n      },\n    }\n  }\n\n  let scrollWidth\n  $: {\n    let sum = 0\n    tableHeaders.forEach((header) => {\n      sum += header.width\n    })\n    scrollWidth = sum\n  }\n\n  function onRowExpanded(event) {\n    const row = event.detail.row\n    row.expanded = true\n    if (row.children) show(row.children)\n    updateYPositions()\n  }\n\n  function onRowCollapsed(event) {\n    const row = event.detail.row\n    row.expanded = false\n    if (row.children) hide(row.children)\n    updateYPositions()\n  }\n\n  function updateYPositions() {\n    let y = 0\n    $rowStore.ids.forEach((id) => {\n      const row = $rowStore.entities[id]\n      if (!row.hidden) {\n        $rowStore.entities[id].y = y\n        y += $rowHeight\n      }\n    })\n\n    $taskStore.ids.forEach((id) => {\n      const task = $taskStore.entities[id]\n      const row = $rowStore.entities[task.model.resourceId]\n      $taskStore.entities[id].top = row.y + $rowPadding\n    })\n  }\n\n  function hide(children) {\n    children.forEach((row) => {\n      if (row.children) hide(row.children)\n      row.hidden = true\n    })\n  }\n\n  function show(children, hidden = false) {\n    children.forEach((row) => {\n      if (row.children) show(row.children, !row.expanded)\n      row.hidden = hidden\n    })\n  }\n\n  // if gantt displays a bottom scrollbar and table does not, we need to pad out the table\n  let bottomScrollbarVisible\n  $: {\n    bottomScrollbarVisible = $width > $visibleWidth && scrollWidth <= tableWidth\n  }\n</script>\n\n<style>\n  /* This class should take into account varying widths of the scroll bar */\n  .bottom-scrollbar-visible {\n    padding-bottom: 17px;\n  }\n\n  .sg-table {\n    overflow-x: auto;\n    display: flex;\n    flex-direction: column;\n  }\n\n  .sg-table-scroller {\n    width: 100%;\n    border-bottom: 1px solid #efefef;\n    overflow-y: hidden;\n  }\n\n  .sg-table-header {\n    display: flex;\n    align-items: stretch;\n    overflow: hidden;\n    border-bottom: #efefef 1px solid;\n    background-color: #fbfbfb;\n  }\n\n  .sg-table-rows {\n  }\n\n  .sg-table-body {\n    display: flex;\n    flex: 1 1 0;\n    width: 100%;\n    overflow-y: hidden;\n  }\n\n  .sg-table-header-cell {\n    font-size: 14px;\n    font-weight: 400;\n  }\n\n  :global(.sg-table-cell) {\n    white-space: nowrap;\n    overflow: hidden;\n\n    display: flex;\n    align-items: center;\n    flex-shrink: 0;\n\n    padding: 0 0.5em;\n    height: 100%;\n  }\n\n  :global(.sg-table-cell:last-child) {\n    flex-grow: 1;\n  }\n</style>\n\n<div class=\"sg-table sg-view\" style=\"width:{tableWidth}px;\">\n  <div class=\"sg-table-header\" bind:this={headerContainer}>\n    {#each tableHeaders as header}\n      <div\n        class=\"sg-table-header-cell sg-table-cell {header.classes || ''}\"\n        style=\"width:{header.width}px\">\n        {#if header.headerHtml}\n          {@html header.headerHtml}\n        {:else}{header.title}{/if}\n      </div>\n    {/each}\n  </div>\n\n  <div\n    class=\"sg-table-body\"\n    class:bottom-scrollbar-visible={bottomScrollbarVisible}>\n    <div class=\"sg-table-scroller\" use:scrollListener>\n      <div\n        class=\"sg-table-rows\"\n        style=\"padding-top:{paddingTop}px;padding-bottom:{paddingBottom}px;height:{rowContainerHeight}px;\">\n        {#each visibleRows as row}\n          <TableRow\n            {row}\n            headers={tableHeaders}\n            on:rowExpanded={onRowExpanded}\n            on:rowCollapsed={onRowCollapsed} />\n        {/each}\n      </div>\n    </div>\n  </div>\n\n  <div class=\"sg-table-header\" bind:this={headerContainer}>\n    {#each tableLastHeaders as header}\n      <div\n        class=\"sg-table-header-cell sg-table-cell {header.classes || ''}\"\n        style=\"width:{header.width}px\">\n        {#if header.headerHtml}\n          {@html header.headerHtml}\n        {:else}{header.title}{/if}\n      </div>\n    {/each}\n  </div>\n</div>\n",
    "<script>\n    import { createEventDispatcher, getContext } from \"svelte\";\n\n    import TableTreeCell from './TableTreeCell.svelte';\n\n    export let headers = null;\n    export let row = null;\n\n    const { rowHeight } = getContext('options');\n    const { hoveredRow, selectedRow } = getContext('gantt');\n\n    const dispatch = createEventDispatcher();\n\n    let treeIndentationStyle = '';\n    $: {\n        treeIndentationStyle = row.parent ? `padding-left: ${row.childLevel*3}em;`:'';\n    }\n\n</script>\n\n<div class=\"sg-table-row {row.model.class || ''}\" style=\"height:{$rowHeight}px\" data-row-id={row.model.id} class:sg-row-expanded=\"{row.expanded}\" class:sg-hover={$hoveredRow == row.model.id} class:sg-selected={$selectedRow == row.model.id}>\n    {#each headers as header}\n        <div class=\"sg-table-body-cell sg-table-cell\" style=\"width:{header.width}px\">\n            {#if header.type == 'tree'}\n                <TableTreeCell on:rowCollapsed on:rowExpanded {row}>\n                    {#if row.model.iconClass}\n                    <div class=\"sg-table-icon\">\n                        <i class=\"{row.model.iconClass}\"></i>\n                    </div>\n                    {/if}\n\n                    {#if row.model.headerHtml}\n                        {@html row.model.headerHtml}\n                    {:else if header.renderer}\n                        {@html header.renderer(row)}\n                    {:else}\n                        {row.model[header.property]}\n                    {/if}\n                </TableTreeCell>\n            {:else}\n                {#if row.model.iconClass}\n                <div class=\"sg-table-icon\">\n                    <i class=\"{row.model.iconClass}\"></i>\n                </div>\n                {/if}\n\n                {#if row.model.headerHtml}\n                    {@html row.model.headerHtml}\n                {:else if header.renderer}\n                    {@html header.renderer(row)}\n                {:else if header.type === 'resourceInfo'}\n                    <img class=\"sg-resource-image\" src=\"{row.model.imageSrc}\" alt=\"\"/>\n                    <div class=\"sg-resource-title\">\n                        {row.model[header.property]}\n                    </div>\n                {:else}\n                    {row.model[header.property]}\n                {/if}\n            {/if}\n        </div>\n    {/each}\n</div>\n<style>\n    .sg-table-row {\n        display: inline-flex;\n        min-width: 100%;\n        align-items: stretch;\n\n        position: relative;\n\n        font-weight: 400;\n        font-size: 14px;\n    }\n\n    .sg-table-cell {\n        border-left: 1px solid #eee;\n    }\n\n    .sg-table-body-cell {\n        border-bottom: #efefef 1px solid;\n        background-color: #fff;\n        font-weight: bold;\n    }\n\n    .sg-resource-image {\n        width: 2.4em;\n        height: 2.4em;\n        border-radius: 50%;\n        margin-right: .6em;\n\n        background: #047c69;\n    }\n\n    .sg-resource-info {\n        flex: 1;\n        height: 100%;\n        display: flex;\n        flex-direction: row;\n        align-items: center;\n    }\n\n    .sg-table-icon {\n        margin-right: 0.5em;\n    }\n</style>",
    "<script>\n    import { createEventDispatcher, getContext } from \"svelte\";\n\n    export let row;\n    \n    const dispatch = createEventDispatcher();\n\n    function onExpandToggle() {\n        if(row.expanded) {\n            dispatch('rowCollapsed', { row });\n        } else {\n            dispatch('rowExpanded', { row });\n        }\n    }\n</script>\n\n<div class=\"sg-cell-inner\" style=\"padding-left: {row.childLevel*3}em\">\n    {#if row.children}\n        <div class=\"sg-tree-expander\" on:click=\"{onExpandToggle}\">\n            {#if row.expanded}\n            <i class=\"fas fa-angle-down\"></i>\n            {:else}\n            <i class=\"fas fa-angle-right\"></i>\n            {/if}\n        </div>\n    {/if}\n    <slot></slot>\n</div>\n\n<style>\n    .sg-tree-expander {\n        cursor: pointer;\n        min-width: 1.4em;\n        display: flex;\n        justify-content: center;\n        align-items: center;\n    }\n\n    .sg-cell-inner {\n        display: flex;\n    }\n</style>"
  ],
  "names": [],
  "mappings": "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"
}